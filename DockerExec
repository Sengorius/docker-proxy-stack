#!/usr/bin/env bash

SCRIPT_PATH=$(realpath "$0")
export SCRIPT_PATH

BASE_DIR=$(dirname "$SCRIPT_PATH")
export BASE_DIR

CURRENT_DIR=$(pwd)
export CURRENT_DIR

export ENV_FILE=".env"
export LINUX_HOSTS=/etc/hosts
export STATUS_FILE_NAME="docker_current.txt"
export TEMP_HOSTS_FILE=".current-hosts"
export UPD_FILE_NAME=".last-update"

export SRC_DIR="$BASE_DIR/src"
export PROXY_ENV_FILE="$BASE_DIR/$ENV_FILE"
export CERTS_PATH="$BASE_DIR/certs"
export TEMP_HOSTS_PATH="$BASE_DIR/$TEMP_HOSTS_FILE"
export UPD_FILE_PATH="$BASE_DIR/$UPD_FILE_NAME"
export SPAWNS_AVAIL_PATH="$BASE_DIR/spawns-available"
export SPAWNS_ENABLED_PATH="$BASE_DIR/spawns-enabled"

# include variables from .env file in source directory
# shellcheck disable=SC1090
source "$PROXY_ENV_FILE"

# include scripts
. "$SRC_DIR/warnings.sh"
. "$SRC_DIR/helpers.sh"
. "$SRC_DIR/security.sh"
. "$SRC_DIR/generate.sh"
. "$SRC_DIR/spawns.sh"
. "$SRC_DIR/main.sh"


###
### How to install this script
###
if [[ ! -f "$PROXY_ENV_FILE" ]]; then
    echo
    echo -e "${COLOR_BLUE}Installation:"
    echo
    echo -e "  ${COLOR_WHITE}Make sure to clone the repository via ${COLOR_ORANGE}git clone${COLOR_WHITE} to this machine."
    echo -e "  Then copy the .env.template for a .env and adapt it to your needs."
    echo
    echo -e "  You should also create a softlink or alias for DockerExec, e.g."
    echo -e "  ${COLOR_ORANGE}ln -s /path/to/this/docker-proxy/DockerExec /home/\$USER/.local/bin/DockerExec${COLOR_WHITE}"
    echo

    exit 0
fi


###
### start of program
###

# get the arguments and set default parameter, if none was given
ENVIRONMENT=$1; shift

case "$ENVIRONMENT" in
    dev|prod|proxy|spawn|do)
        ACTION=$1; shift
        ;;
    *)
        ACTION="$ENVIRONMENT"
        ENVIRONMENT="do"
        ;;
esac

PARAMETERS=("$@")

if [[ -z "$ACTION" ]]; then
    ACTION="ps"
fi

# return the help statement, if asked for
if [[ "help" == "$ACTION" || "--help" == "$ACTION" || "-h" == "$ACTION" ]]; then
    BN=$(basename "$0")

    echo
    echo -e "${COLOR_WHITE}Usage:"
    echo -e "  $BN ${COLOR_GREEN}[Environment] ${COLOR_BLUE}[Option] ${COLOR_RED}[\$Parameter(s)] ${COLOR_WHITE}"
    echo
    echo -e "${COLOR_WHITE}Environments and their options:"
    echo -e " ${COLOR_GREEN}dev${COLOR_WHITE}: Controls for docker-compose.yml and docker-compose.dev.yml"
    echo -e "    ${COLOR_BLUE}start${COLOR_WHITE}              - executes an extended docker-compose setup with the local file"
    echo -e "    ${COLOR_BLUE}stop${COLOR_WHITE}               - shutdown for the local docker-compose setup"
    echo
    echo -e " ${COLOR_GREEN}prod${COLOR_WHITE}: Controls for docker-compose.prod.yml"
    echo -e "    ${COLOR_BLUE}start${COLOR_WHITE}              - executes an extended docker-compose setup with the local file"
    echo -e "    ${COLOR_BLUE}stop${COLOR_WHITE}               - shutdown for the local docker-compose setup"
    echo
    echo -e " ${COLOR_GREEN}proxy${COLOR_WHITE}: Controls docker-compose.proxy.yml and the proxy stack"
    echo -e "    ${COLOR_BLUE}init${COLOR_WHITE}               - starts the docker NGINX proxy stack and creates a netzwork, if necessary"
    echo -e "    ${COLOR_BLUE}finish${COLOR_WHITE}             - shuts the docker NGINX proxy stack down"
    echo -e "    ${COLOR_BLUE}start${COLOR_WHITE}              - executes an extended docker-compose setup with the local file"
    echo -e "    ${COLOR_BLUE}stop${COLOR_WHITE}               - shutdown for the local docker-compose setup"
    echo -e "    ${COLOR_BLUE}db ${COLOR_RED}[\$db \$f]${COLOR_WHITE}        - running a bash on the MySQL proxy database [or will import an .sql file with specified \$dbname and \$filename]"
    echo -e "    ${COLOR_BLUE}pg ${COLOR_RED}[\$db \$f]${COLOR_WHITE}        - running a bash on the Postgres proxy database [or will import an .sql file with specified \$dbname and \$filename]"
    echo -e "    ${COLOR_BLUE}generate${COLOR_WHITE} ${COLOR_RED}[\$dp]${COLOR_WHITE}     - creates a docker-compose.proxy.yaml + .env file with linked [\$dp].docker.test"
    echo
    echo -e " ${COLOR_GREEN}spawn${COLOR_WHITE}: Create or edit proxy containers"
    echo -e "    ${COLOR_BLUE}status${COLOR_WHITE}             - returns details about available and enabled spawns"
    echo -e "    ${COLOR_BLUE}enable${COLOR_WHITE}             - enables a configured container from 'spawns-available' namespace"
    echo -e "    ${COLOR_BLUE}disable${COLOR_WHITE}            - disables a configured container from 'spawns-enabled' namespace"
    echo -e "    ${COLOR_BLUE}create${COLOR_WHITE}             - creates a new spawn file from given input"
    echo -e "    ${COLOR_BLUE}mailcatcher${COLOR_WHITE}        - create a mailcatcher spawn from Skript-Manufaktur"
    echo -e "    ${COLOR_BLUE}legacy${COLOR_WHITE}             - create the legacy containers from first version of the Docker-Proxy-Stack"
    echo
    echo -e " ${COLOR_GREEN}do${COLOR_WHITE}: Other tools"
    echo -e "    ${COLOR_BLUE}ps${COLOR_WHITE}                 - lists all containers like 'docker ps -a'"
    echo -e "    ${COLOR_BLUE}remove${COLOR_WHITE}             - does a 'docker rm' to all containers that have stopped running"
    echo -e "    ${COLOR_BLUE}cleanup${COLOR_WHITE}            - deletes all docker images, that have a <none> as tag name or image id"
    echo -e "    ${COLOR_BLUE}finish${COLOR_WHITE}             - stops and removes all current containers, like 'docker stop && docker rm'"
    echo -e "    ${COLOR_BLUE}watch-running ${COLOR_RED}\$cn${COLOR_WHITE}  - tests, whether a container with name '\$cn' is running and returns 'TRUE' or 'FALSE' as a string"
    echo -e "    ${COLOR_BLUE}status ${COLOR_RED}[\$fn]${COLOR_WHITE}       - creates a text file [\$fn] in current location that contains a list of images and runninge containers on this machine"
    echo -e "    ${COLOR_BLUE}init-certs${COLOR_WHITE}         - create openssl certificates to be registered in your browsers"
    echo -e "    ${COLOR_BLUE}self-update${COLOR_WHITE}        - update the Docker Proxy Stack with the latest tag"
    echo

    exit 0
fi

# test existence of docker and docker-compose
command -v docker > /dev/null 2>&1 || {
    print_error "There was no docker executable found on this machine. Did you install docker correctly?" 1
    exit 1
}

command -v docker-compose > /dev/null 2>&1 || {
    print_error "There was no docker-composer executable found on this machine. Did you install docker correctly?"
    print_error "If you use a differen alias, please create one called 'docker-compose' for your user." 1
    exit 1
}

# add environment variables for docker
COMPOSE_DOCKER_CLI_BUILD=0
export COMPOSE_DOCKER_CLI_BUILD

DOCKER_BUILDKIT=0
export DOCKER_BUILDKIT


###
### check for updates and execute environment + action
###
check_for_updates

# watch the environment
if [[ "dev" == "$ENVIRONMENT" ]]; then
    # test project files
    if ! COMPOSE=$(test_files "$ENV_FILE" "docker-compose"); then
        echo "$COMPOSE"
        exit 1
    fi

    # start the docker-compose
    if [[ "start" == "$ACTION" ]]; then
        compose_run "$COMPOSE" "$ENV_FILE"

    # stop and remove the containers
    elif [[ "stop" == "$ACTION" ]]; then
        docker-compose stop
        docker-compose rm -f

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

elif [[ "prod" == "$ENVIRONMENT" ]]; then
    # test project files
    if ! COMPOSE=$(test_files "$ENV_FILE" "docker-compose.prod"); then
        echo "$COMPOSE"
        exit 1
    fi

    # start the docker-compose
    if [[ "start" == "$ACTION" ]]; then
        compose_run "$COMPOSE" "$ENV_FILE"

    # stop and remove the containers
    elif [[ "stop" == "$ACTION" ]]; then
        update_host_files "$ENV_FILE" "remove"
        docker-compose -f "$COMPOSE" stop
        docker-compose -f "$COMPOSE" rm -f

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

elif [[ "proxy" == "$ENVIRONMENT" ]]; then
    COMPOSE="docker-compose.proxy"

    # start docker-proxy in proxy path
    if [[ "init" == "$ACTION" ]]; then
        cd "$BASE_DIR" || (print_error "Could not change directory to $BASE_DIR" && exit 1)

        # check the /certs directory
        if [[ ! -d "$CERTS_PATH" || ! -f "$CERTS_PATH/docker.test.key" ]]; then
            print_warning "The proxy is not fully configured, yet! Try 'DockerExec init-certs' to fix this."
        fi

        # first, test if the network exists and create, if not
        if ! docker network ls | grep -q "$NETWORK_NAME"; then
            docker network create --attachable "$NETWORK_NAME"
            print_info "Network $NETWORK_NAME was created successfully!"
        fi

        # ensure the proxy main container is enabled
        ensure_proxy_main

        # ensure the docker.test domain is located in hosts file
        publish_single_entry_hosts_file "docker.test"

        # reset the temporary hosts
        if [[ -f "$TEMP_HOSTS_PATH" ]]; then
            rm "$TEMP_HOSTS_PATH"
        fi
        touch "$TEMP_HOSTS_PATH"

        DOCKER_LOGS=

        # shellcheck disable=SC2045
        for file in $(ls "$SPAWNS_ENABLED_PATH"); do
            SPAWN_FILE="$SPAWNS_ENABLED_PATH/$file"
            CON_NAME=$(grep "^CONTAINER_NAME=" "$SPAWN_FILE" | sed -e 's/^CONTAINER_NAME=//' | tr -d '"' | sed -e 's/[[:space:]]*$//')
            DOCKER_LOGS="docker logs --details -f $CON_NAME & $DOCKER_LOGS"
            RUNNING_CONTAINER=$(docker ps -aq -f name="$CON_NAME")

            if [[ -z "$RUNNING_CONTAINER" ]]; then
                # shellcheck disable=SC1090
                . "$SPAWN_FILE" > /dev/null

                [[ $(grep "VIRTUAL_HOST" "$SPAWN_FILE") =~ VIRTUAL_HOST=(.*)[[:space:]] ]]
                CON_HOST=${BASH_REMATCH[1]}

                print_info "Started container $CON_NAME"
                if [[ -n "$CON_HOST" ]]; then
                    echo "  https://$CON_HOST"
                fi
            fi
        done

        # add all proxy containers (with there IP and hostname) to current hosts file
        update_host_files_with_proxy

        # if attaching to logs is enabled, use the "{ command1 & command2 }" notation to aggregate docker logs
        if [[ -z "$ATTACH_TO_COMPOSE_LOGS" || "1" == "$ATTACH_TO_COMPOSE_LOGS" ]]; then
            DOCKER_LOGS=${DOCKER_LOGS%' & '}
            /bin/sh -c "{ $DOCKER_LOGS; }"
        fi

    # stop and remove the proxy
    elif [[ "finish" == "$ACTION" ]]; then
        if [[ -n $(docker ps -a --format "{{ .Names }}" -f name="proxy-") ]]; then
            cd "$BASE_DIR" || (print_error "Could not change directory to $BASE_DIR" && exit 1)
            print_info "Shutting down proxy..."
            docker-compose stop > /dev/null
            docker-compose rm -f > /dev/null
        else
            print_info "The Proxy is not started. No containers to stop."
        fi

        # remove the temporary hosts
        if [[ -f "$TEMP_HOSTS_PATH" ]]; then
            rm "$TEMP_HOSTS_PATH"
        fi

    # start the docker-compose
    elif [[ "start" == "$ACTION" ]]; then
        # test project files
        if ! COMPOSE=$(test_files "$ENV_FILE" "$COMPOSE"); then
            echo "$COMPOSE"
            exit 1
        fi

        # test, if the proxy is already running
        if [[ 0 == $(is_proxy_running) ]]; then
            print_error "The proxy is not running, yet. Initialize with 'DockerExec proxy init'" 1
            exit 1
        fi

        # print out all found hosts and start
        print_hosts "$COMPOSE"
        compose_run "$COMPOSE" "$ENV_FILE"

    # stop and remove the containers
    elif [[ "stop" == "$ACTION" ]]; then
        # test project files
        if ! COMPOSE=$(test_files "$ENV_FILE" "$COMPOSE"); then
            echo "$COMPOSE"
            exit 1
        fi

        update_host_files "$ENV_FILE" "remove"
        docker-compose -f "$COMPOSE" stop
        docker-compose -f "$COMPOSE" rm -f

    # start the docker proxy db with bash
    elif [[ "db" == "$ACTION" ]]; then
        DB_NAME=$(grep "^DB_NAME=" "$PROXY_ENV_FILE" | sed -e 's/^DB_NAME=//' | sed -e 's/[[:space:]]*$//')
        RUNNING_APP=$(docker ps -aq -f name="$DB_NAME" -f status="running")

        if [[ -n "$RUNNING_APP" ]]; then
            USE_DATABASE="${PARAMETERS[0]}"
            USE_DB_FILE="${PARAMETERS[1]}"

            if [[ -n "$USE_DATABASE" && -n "$USE_DB_FILE" ]]; then
                docker exec -it "$DB_NAME" bash -c "mysql -proot -e 'CREATE DATABASE IF NOT EXISTS $USE_DATABASE' && mysql -proot '$USE_DATABASE' < '/var/data/$USE_DB_FILE'" > /dev/null 2>&1
                print_info "Done"
            else
                docker exec -it "$DB_NAME" bash -c "cd /var/data && bash"
            fi

        else
            print_error "The $DB_NAME container is not up and running..." 1
            exit 1
        fi

    # start the docker proxy pg with bash
    elif [[ "pg" == "$ACTION" ]]; then
        PG_NAME=$(grep "^PG_NAME=" "$PROXY_ENV_FILE" | sed -e 's/^PG_NAME=//' | sed -e 's/[[:space:]]*$//')
        RUNNING_APP=$(docker ps -aq -f name="$PG_NAME" -f status="running")

        if [[ -n "$RUNNING_APP" ]]; then
            USE_DATABASE="${PARAMETERS[0]}"
            USE_DB_FILE="${PARAMETERS[1]}"

            if [[ -n "$USE_DATABASE" && -n "$USE_DB_FILE" ]]; then
                docker exec -it "$PG_NAME" bash -c "echo \"SELECT 'CREATE DATABASE $USE_DATABASE' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$USE_DATABASE')\gexec\" | psql && psql -d '$USE_DATABASE' < '/var/data/$USE_DB_FILE'" > /dev/null 2>&1
                print_info "Done"
            else
                docker exec -it "$PG_NAME" bash -c "cd /var/data && bash"
            fi

        else
            print_error "The $PG_NAME container is not up and running..." 1
            exit 1
        fi

    # generate a docker-compose.proxy.yaml with a basic configuration
    elif [[ "generate" == "$ACTION" ]]; then
        DOMAIN_PREFIX="${PARAMETERS[0]}"

        if [[ -z "$DOMAIN_PREFIX" ]]; then
            DOMAIN_PREFIX="my-project"
        fi

        if [[ ! ( -f "./$COMPOSE.yml" || -f "./$COMPOSE.yaml" ) ]]; then
            generate_docker_compose_project "docker-compose.proxy.yaml" "$DOMAIN_PREFIX"
            print_info "A docker-compose.proxy.yaml was added."
        fi

        if [[ ! -f "./$ENV_FILE" ]]; then
            generate_env_file_project "$ENV_FILE" "$DOMAIN_PREFIX"
            print_info "A $ENV_FILE was added."
        fi

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

elif [[ "spawn" == "$ENVIRONMENT" ]]; then
    # print spawn details
    if [[ "status" == "$ACTION" ]]; then
        print_info "Following spawn containers are available:"
        find "$SPAWNS_AVAIL_PATH" -maxdepth 1 -type f,l -printf "  - %f\n"
        echo

        print_info "Following spawn containers are enabled in order:"
        find "$SPAWNS_ENABLED_PATH" -maxdepth 1 -type f,l -exec basename {} \; | sort | awk '{print "  - "$1}'
        echo

    # link an existing spawn from available to enabled
    elif [[ "enable" == "$ACTION" ]]; then
        enable_spawn_container "${PARAMETERS[0]}" "${PARAMETERS[1]}"

    # or remove the link from enabled directory
    elif [[ "disable" == "$ACTION" ]]; then
        disable_spawn_container "${PARAMETERS[0]}"

    # create a new spawn file in available spawns directory
    elif [[ "create" == "$ACTION" ]]; then
        spawn_container_from_questions

    # spawn a container for mailcatching
    elif [[ "mailcatcher" == "$ACTION" ]]; then
        spawn_smt_mailcatcher

    # ask and spawn the containers related to Docker-Proxy-Stack v1
    elif [[ "legacy" == "$ACTION" ]]; then
        spawn_legacy_proxy_stack
    fi

elif [[ "do" == "$ENVIRONMENT" ]]; then
    # stop, then remove all containers
    if [[ "finish" == "$ACTION" ]]; then
        REMOVABLE_CONTAINERS=$(docker ps -aq)
        if [[ -n "$REMOVABLE_CONTAINERS" ]]; then
            print_info "Shutting down..."
            # shellcheck disable=SC2086
            docker stop $REMOVABLE_CONTAINERS > /dev/null
            # shellcheck disable=SC2086
            docker rm -f $REMOVABLE_CONTAINERS > /dev/null
        else
            print_info "No containers to stop."
        fi

        if [[ -f "$TEMP_HOSTS_PATH" ]]; then
            rm "$TEMP_HOSTS_PATH"
        fi

    # remove all stopped containers
    elif [[ "remove" == "$ACTION" ]]; then
        EXITED_CONTAINERS=$(docker ps -aq -f status="exited")
        if [[ -n "$EXITED_CONTAINERS" ]]; then
            # shellcheck disable=SC2086
            docker rm -f $EXITED_CONTAINERS
        else
            print_info "No containers to remove."
        fi

    # remove all images that are no more in use
    elif [[ "cleanup" == "$ACTION" ]]; then
        CLEANABLE_CONTAINERS=$(docker images | grep "<none>" | awk "{print \$3}")
        if [[ -n "$CLEANABLE_CONTAINERS" ]]; then
            # shellcheck disable=SC2086
            docker rmi -f $CLEANABLE_CONTAINERS
        else
            print_info "No unfinished build layers to remove."
        fi

    # test, if a container is running
    elif [[ "watch-running" == "$ACTION" || "watchrunning" == "$ACTION" || "watch" == "$ACTION" ]]; then
        CONTAINER="${PARAMETERS[0]}"

        if [[ -z "$CONTAINER" ]]; then
            print_error "To test a container, please provide its name!" 1
            exit 1
        fi

        STATE=$(docker ps -a --format "table {{.Status}}\t{{.Names}}" | grep "$CONTAINER")

        if [[ $STATE == *"Up "* ]]; then
            echo "TRUE"
        else
            echo "FALSE"
        fi

    # print the current state of Docker into a file
    elif [[ "status" == "$ACTION" ]]; then
        # let's see, if a file name was given
        REAL_STATUS_FILE="$STATUS_FILE_NAME"

        if [[ 0 != "${#PARAMETERS[@]}" ]]; then
            REAL_STATUS_FILE="${PARAMETERS[0]}"
        fi

        # create the full path and ask for confirmation
        STATUS_PATH="$CURRENT_DIR/$REAL_STATUS_FILE"
        read -r -p "A file $REAL_STATUS_FILE will be created (or override existing). Continue? [Y/n]" input

        case $input in
            [yY][eE][sS]|[yY])
                # remove the existing file
                if [[ -f "$STATUS_PATH" ]]; then
                    rm -f "$STATUS_PATH"
                fi

                # print out status info into a static file
                echo "### Currently running containers" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                docker ps -a --format "table {{.Image}}\t{{.Status}}\t{{.Ports}}\t{{.Names}}" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                echo "### Currently existing images" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                docker images >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                ;;
            *)
                print_error "Canceled..." 1
                ;;
        esac

    # use prompts to generate certificates for browser usage
    # see https://gist.github.com/fntlnz/cf14feb5a46b2eda428e000157447309
    # see https://two-oes.medium.com/working-with-openssl-and-dns-alternative-names-367f06a23841
    # see https://www.openssl.org/docs/manmaster/man5/x509v3_config.html
    # to test a .crt file, try: openssl x509 -in certs/docker.test.crt -text -noout
    elif [[ "init-certs" == "$ACTION" || "initcerts" == "$ACTION" ]]; then
        command -v openssl > /dev/null 2>&1 || {
            print_error "Openssl seems not to be installed on this machine. But it is necessary to generate keys..." 1
            exit 1
        }

        # create the certs path, if not done, yet
        if [[ ! -d "$CERTS_PATH" ]]; then
            mkdir -p "$CERTS_PATH"
        fi

        # some security info
        print_info "Attention: This is the key used to sign the certificate requests. Anyone holding this can sign certificates on your behalf. So keep it safe!"

        # ask the user for some details on the certificate
        RSA_KEY_LENGTH=$(match_answer_or_default "Define a key size [4096]: " 4096)
        RSA_VALID_DAYS=$(match_answer_or_default "How long shall this certificate be valid (in days) [3650]: " 3650)
        RSA_COUNTRY_NAME=$(match_answer_or_default "Country Name (2 letter code) [PS]: " "PS")
        RSA_STATE_NAME=$(match_answer_or_default "State or Province Name (full name) [Proxy Environment]: " "Proxy Environment")
        RSA_LOCALITY_NAME=$(match_answer_or_default "Locality Name (some city) [Proxy]: " "Proxy")
        RSA_ORG_NAME=$(match_answer_or_default "Organization Name (some company) [Docker Proxy Stack]: " "Docker Proxy Stack")
        RSA_ORGUNIT_NAME=$(match_answer_or_default "Organizational Unit Name (a section) [Docker Proxy Stack]: " "Docker Proxy Stack")
        RSA_EMAIL=$(match_answer_or_default "E-Mail Address []: " "")

        generate_openssl_certs "$RSA_KEY_LENGTH" "$RSA_VALID_DAYS" "$RSA_COUNTRY_NAME" "$RSA_STATE_NAME" \
                               "$RSA_LOCALITY_NAME" "$RSA_ORG_NAME" "$RSA_ORGUNIT_NAME" "$RSA_EMAIL"

        print_info "Done creating rootCA and certificates in $CERTS_PATH."
        print_info "Now register the rootCA.crt in your browser." 1

    # shortcut to list all docker containers
    elif [[ "self-update" == "$ACTION" || "selfupdate" == "$ACTION" ]]; then
        # get_latest_git_tag will cd us into the $BASE_DIR directory
        LATEST_TAG=$(get_latest_git_tag)
        git checkout --quiet "$LATEST_TAG"
        print_info "Updated the Docker Proxy Stack. Checked out version $LATEST_TAG." 1

        print_info "There are major changes from v1 to $LATEST_TAG. If you upgraded from v1 to v2, please"
        print_info "follow the upgrade instructions, to get the Docker-Proxy-Stack up and running again!"
        print_info " >> https://sengorius.github.io/repositories/docker-proxy/upgrade-v2.html"

    # shortcut to list all docker containers
    elif [[ "ps" == "$ACTION" ]]; then
        docker ps -a --format "table {{.Image}}\t{{.Status}}\t{{.Ports}}\t{{.Names}}"

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

else
    print_error "There is no environment named '$ENVIRONMENT'..." 1
    exit 1
fi

exit 0
