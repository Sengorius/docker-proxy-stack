#!/usr/bin/env bash

export SCRIPT_PATH=`realpath "$0"`
export BASE_DIR=`dirname "$SCRIPT_PATH"`
export SRC_DIR="$BASE_DIR/src"

# include scripts
. "$SRC_DIR/warnings.sh"
. "$SRC_DIR/helpers.sh"
. "$SRC_DIR/security.sh"
. "$SRC_DIR/main.sh"


###
### How to install this script
###
if [[ -z "$PROXY_PATH" ]]; then
    echo
    echo -e "${COLOR_BLUE}Installation:"
    echo
    echo -e "  ${COLOR_WHITE}Make sure to clone the repository via ${COLOR_ORANGE}git clone${COLOR_WHITE} to this machine."
    echo -e "  Then open the ~/.bashrc file in an editor and add following lines:"
    echo
    echo -e "${COLOR_ORANGE}    # enable DockerExec (docker-proxy-stack)${COLOR_WHITE}"
    echo -e "${COLOR_ORANGE}    PROXY_PATH='${SCRIPT_PATH}'${COLOR_WHITE} # change this, if necessary"
    echo -e "${COLOR_ORANGE}    alias DockerExec='PROXY_PATH=\$PROXY_PATH ${SCRIPT_PATH}'${COLOR_WHITE} # do not change this"
    echo
    echo -e "  On Windows, the .bashrc is probably located at ${COLOR_ORANGE}C:\Users\%username%\.bashrc${COLOR_WHITE},"
    echo -e "  if 'Git for Windows' or some WSL is installed."
    echo

    exit 0
fi


###
### start of program
###

# get the arguments and set default parameter, if none was given
ENVIRONMENT=$1; shift

case "$ENVIRONMENT" in
    dev|prod|proxy|do)
        ACTION=$1; shift
        ;;
    *)
        ACTION="$ENVIRONMENT"
        ENVIRONMENT="do"
        ;;
esac

PARAMETERS=("$@")

if [[ -z "$ACTION" ]]; then
    ACTION="ps"
fi

# return the help statement, if asked for
if [[ "help" == "$ACTION" || "--help" == "$ACTION" || "-h" == "$ACTION" ]]; then
    BN=`basename $0`

    echo
    echo -e "${COLOR_WHITE}Usage:"
    echo -e "  $BN ${COLOR_GREEN}[Environment] ${COLOR_BLUE}[Option] ${COLOR_RED}[\$Parameter(s)] ${COLOR_WHITE}"
    echo
    echo -e "${COLOR_WHITE}Environments and their options:"
    echo -e " ${COLOR_GREEN}dev${COLOR_WHITE}: Controls for docker-compose.yml and docker-compose.dev.yml"
    echo -e "    ${COLOR_BLUE}start${COLOR_WHITE}              - executes an extended docker-compose setup with the local file"
    echo -e "    ${COLOR_BLUE}stop${COLOR_WHITE}               - shutdown for the local docker-compose setup"
    echo
    echo -e " ${COLOR_GREEN}prod${COLOR_WHITE}: Controls for docker-compose.prod.yml"
    echo -e "    ${COLOR_BLUE}start${COLOR_WHITE}              - executes an extended docker-compose setup with the local file"
    echo -e "    ${COLOR_BLUE}stop${COLOR_WHITE}               - shutdown for the local docker-compose setup"
    echo
    echo -e " ${COLOR_GREEN}proxy${COLOR_WHITE}: Controls docker-compose.proxy.yml and the proxy stack"
    echo -e "    ${COLOR_BLUE}init${COLOR_WHITE}               - starts the docker NGINX proxy stack and creates a netzwork, if necessary"
    echo -e "    ${COLOR_BLUE}finish${COLOR_WHITE}             - shuts the docker NGINX proxy stack down"
    echo -e "    ${COLOR_BLUE}start${COLOR_WHITE}              - executes an extended docker-compose setup with the local file"
    echo -e "    ${COLOR_BLUE}stop${COLOR_WHITE}               - shutdown for the local docker-compose setup"
    echo -e "    ${COLOR_BLUE}db ${COLOR_RED}[\$db \$f]${COLOR_WHITE}        - running a bash on the MySQL proxy database [or will import an .sql file with specified \$dbname and \$filename]"
    echo -e "    ${COLOR_BLUE}pg ${COLOR_RED}[\$db \$f]${COLOR_WHITE}        - running a bash on the Postgres proxy database [or will import an .sql file with specified \$dbname and \$filename]"
    echo -e "    ${COLOR_BLUE}generate${COLOR_WHITE} ${COLOR_RED}[\$dp]${COLOR_WHITE}     - creates a docker-compose.proxy.yaml + .env file with linked [\$dp].docker.test"
    echo
    echo -e " ${COLOR_GREEN}do${COLOR_WHITE}: Other tools"
    echo -e "    ${COLOR_BLUE}ps${COLOR_WHITE}                 - lists all containers like 'docker ps -a'"
    echo -e "    ${COLOR_BLUE}remove${COLOR_WHITE}             - does a 'docker rm' to all containers that have stopped running"
    echo -e "    ${COLOR_BLUE}cleanup${COLOR_WHITE}            - deletes all docker images, that have a <none> as tag name or image id"
    echo -e "    ${COLOR_BLUE}finish${COLOR_WHITE}             - stops and removes all current containers, like 'docker stop && docker rm'"
    echo -e "    ${COLOR_BLUE}watch-running ${COLOR_RED}\$cn${COLOR_WHITE}  - tests, whether a container with name '\$cn' is running and returns 'TRUE' or 'FALSE' as a string"
    echo -e "    ${COLOR_BLUE}status ${COLOR_RED}[\$fn]${COLOR_WHITE}       - creates a text file [\$fn] in current location that contains a list of images and runninge containers on this machine"
    echo -e "    ${COLOR_BLUE}init-certs${COLOR_WHITE}         - create openssl certificates to be registered in your browsers"
    echo -e "    ${COLOR_BLUE}self-update${COLOR_WHITE}        - update the Docker Proxy Stack with the latest tag"
    echo

    exit 0
fi

# test, if proxy directory is existing
if [[ ! -z "$PROXY_PATH" && ! -d "$PROXY_PATH" ]]; then
    print_error "The path to the docker-proxy-stack directory seems no to be configured correctly..." 1
    exit 1
fi

# test existence of docker and docker-compose
command -v docker > /dev/null 2>&1 || {
    print_error "There was no docker executable found on this machine. Did you install docker correctly?" 1
    exit 1
}

command -v docker-compose > /dev/null 2>&1 || {
    print_error "There was no docker-composer executable found on this machine. Did you install docker correctly?"
    print_error "If you use a differen alias, please create one called 'docker-compose' for your user." 1
    exit 1
}

# add environment variables for docker
export COMPOSE_DOCKER_CLI_BUILD=0
export DOCKER_BUILDKIT=0

# remove the trailing slash
export PROXY_PATH=${PROXY_PATH%/}

# set some more defaults
export ENV_FILE=".env"
export PROXY_ENV_FILE="$PROXY_PATH/$ENV_FILE"
export CURRENT_DIR=`pwd`
export LINUX_HOSTS=/etc/hosts
export CERTS_PATH="$PROXY_PATH/certs"
export STATUS_FILE_NAME="docker_current.txt"
export TEMP_HOSTS_FILE=".current-hosts"
export TEMP_HOSTS_PATH="$PROXY_PATH/$TEMP_HOSTS_FILE"

check_for_updates

# watch the environment
if [[ "dev" == "$ENVIRONMENT" ]]; then
    # test project files
    COMPOSE=`test_files "$ENV_FILE" "docker-compose"`
    if [[ "0" != "$?" ]]; then
        echo $COMPOSE
        exit 1
    fi

    # start the docker-compose
    if [[ "start" == "$ACTION" ]]; then
        compose_run "$COMPOSE" "$ENV_FILE"

    # stop and remove the containers
    elif [[ "stop" == "$ACTION" ]]; then
        docker-compose stop
        docker-compose rm -f

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

elif [[ "prod" == "$ENVIRONMENT" ]]; then
    # test project files
    COMPOSE=`test_files "$ENV_FILE" "docker-compose.prod"`
    if [[ "0" != "$?" ]]; then
        echo $COMPOSE
        exit 1
    fi

    # start the docker-compose
    if [[ "start" == "$ACTION" ]]; then
        compose_run "$COMPOSE" "$ENV_FILE"

    # stop and remove the containers
    elif [[ "stop" == "$ACTION" ]]; then
        update_host_files "$ENV_FILE" "remove"
        docker-compose -f "$COMPOSE" stop
        docker-compose -f "$COMPOSE" rm -f

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

elif [[ "proxy" == "$ENVIRONMENT" ]]; then
    COMPOSE="docker-compose.proxy"

    # start docker-compose in proxy path
    if [[ "init" == "$ACTION" ]]; then
        # go to proxy dir and check for project files
        cd "$PROXY_PATH"
        COMPOSE=`test_files_proxy "$ENV_FILE" "docker-compose"`
        if [[ "0" != "$?" ]]; then
            echo $COMPOSE
            exit 1
        fi

        # check the /certs directory
        if [[ ! -d "$CERTS_PATH" || ! -f "$CERTS_PATH/docker.test.key" ]]; then
            print_warning "The proxy is not fully configured, yet! Try 'DockerExec init-certs' to fix this."
        fi

        # fetch parameters from .env file
        PROXY_NAME=`grep "^PROXY_NAME=" "$ENV_FILE" | sed -e 's/^PROXY_NAME=//' | sed -e 's/[[:space:]]*$//'`
        NETWORK_NAME=`grep "^NETWORK_NAME=" "$ENV_FILE" | sed -e 's/^NETWORK_NAME=//' | sed -e 's/[[:space:]]*$//'`

        # first, test if the network exists and create, if not
        NETWORK_EXISTS=`docker network ls | grep "$NETWORK_NAME"`
        if [[ -z "$NETWORK_EXISTS" ]]; then
            docker network create --attachable "$NETWORK_NAME"
            print_info "Network $NETWORK_NAME was created successfully!"
        fi

        # ensure the docker.test domain is located in hosts file
        publish_single_entry_hosts_file "docker.test"

        # reset the temporary hosts
        if [[ -f "$TEMP_HOSTS_PATH" ]]; then
            rm "$TEMP_HOSTS_PATH"
        fi
        touch "$TEMP_HOSTS_PATH"

        # print out all found hosts and start compose
        print_hosts "$COMPOSE"
        docker-compose up

    # stop and remove the proxy
    elif [[ "finish" == "$ACTION" ]]; then
        if [[ ! -z `docker ps -a --format "{{ .Names }}" -f name="proxy-"` ]]; then
            cd "$PROXY_PATH"
            docker-compose stop
            docker-compose rm -f
        else
            print_info "The Proxy is not started. No containers to stop."
        fi

        # remove the temporary hosts
        if [[ -f "$TEMP_HOSTS_PATH" ]]; then
            rm "$TEMP_HOSTS_PATH"
        fi

    # start the docker-compose
    elif [[ "start" == "$ACTION" ]]; then
        # test project files
        COMPOSE=`test_files "$ENV_FILE" "$COMPOSE"`
        if [[ "0" != "$?" ]]; then
            echo $COMPOSE
            exit 1
        fi

        # test, if the proxy is already running
        if [[ 0 == `is_proxy_running` ]]; then
            print_error "The proxy is not running, yet. Initialize with 'DockerExec proxy init'" 1
            exit 1
        fi

        # print out all found hosts and start
        print_hosts "$COMPOSE"
        compose_run "$COMPOSE" "$ENV_FILE"

    # stop and remove the containers
    elif [[ "stop" == "$ACTION" ]]; then
        # test project files
        COMPOSE=`test_files "$ENV_FILE" "$COMPOSE"`
        if [[ "0" != "$?" ]]; then
            echo $COMPOSE
            exit 1
        fi

        update_host_files "$ENV_FILE" "remove"
        docker-compose -f "$COMPOSE" stop
        docker-compose -f "$COMPOSE" rm -f

    # start the docker proxy db with bash
    elif [[ "db" == "$ACTION" ]]; then
        DB_NAME=`grep "^DB_NAME=" "$PROXY_ENV_FILE" | sed -e 's/^DB_NAME=//' | sed -e 's/[[:space:]]*$//'`
        RUNNING_APP=`docker ps -aq -f name="$DB_NAME" -f status="running"`

        if [[ ! -z "$RUNNING_APP" ]]; then
            USE_DATABASE="${PARAMETERS[0]}"
            USE_DB_FILE="${PARAMETERS[1]}"

            if [[ ! -z "$USE_DATABASE" && ! -z "$USE_DB_FILE" ]]; then
                docker exec -it "$DB_NAME" bash -c "mysql -proot -e 'CREATE DATABASE IF NOT EXISTS $USE_DATABASE' && mysql -proot '$USE_DATABASE' < '/var/data/$USE_DB_FILE'" > /dev/null 2>&1
                print_info "Done"
            else
                docker exec -it "$DB_NAME" bash -c "cd /var/data && bash"
            fi

        else
            print_error "The $DB_NAME container is not up and running..." 1
            exit 1
        fi

    # start the docker proxy pg with bash
    elif [[ "pg" == "$ACTION" ]]; then
        PG_NAME=`grep "^PG_NAME=" "$PROXY_ENV_FILE" | sed -e 's/^PG_NAME=//' | sed -e 's/[[:space:]]*$//'`
        RUNNING_APP=`docker ps -aq -f name="$PG_NAME" -f status="running"`

        if [[ ! -z "$RUNNING_APP" ]]; then
            USE_DATABASE="${PARAMETERS[0]}"
            USE_DB_FILE="${PARAMETERS[1]}"

            if [[ ! -z "$USE_DATABASE" && ! -z "$USE_DB_FILE" ]]; then
                docker exec -it "$PG_NAME" bash -c "echo \"SELECT 'CREATE DATABASE $USE_DATABASE' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$USE_DATABASE')\gexec\" | psql && psql -d '$USE_DATABASE' < '/var/data/$USE_DB_FILE'" > /dev/null 2>&1
                print_info "Done"
            else
                docker exec -it "$PG_NAME" bash -c "cd /var/data && bash"
            fi

        else
            print_error "The $PG_NAME container is not up and running..." 1
            exit 1
        fi

    # generate a docker-compose.proxy.yaml with a basic configuration
    elif [[ "generate" == "$ACTION" ]]; then
        DOMAIN_PREFIX="${PARAMETERS[0]}"

        if [[ -z "$DOMAIN_PREFIX" ]]; then
            DOMAIN_PREFIX="my-project"
        fi

        if [[ ! ( -f "$COMPOSE.yml" || -f "$COMPOSE.yaml" ) ]]; then
            {
                echo "version: '3.5'"
                echo
                echo "services:"
                echo "    web:"
                echo "       image: \${WEB_IMAGE}"
                echo "       container_name: \${CON_PREFIX}-web"
                echo "       env_file: .env"
                echo "       volumes:"
                echo "           - .:/var/www/html"
                echo "       expose:"
                echo "           - 80"
                echo "           - 443"
                echo "       environment:"
                echo "           VIRTUAL_HOST: ${DOMAIN_PREFIX}.docker.test"
                echo "           VIRTUAL_PORT: 443"
                echo "           VIRTUAL_PROTO: https"
                echo "       links:"
                echo "           - php"
                echo
                echo "    php:"
                echo "        image: \${PHP_IMAGE}"
                echo "        container_name: \${CON_PREFIX}-app"
                echo "        env_file: .env"
                echo "        volumes:"
                echo "            - .:/var/www/html"
                echo
                echo "networks:"
                echo "    default:"
                echo "        external: true"
                echo "        name: \${NETWORK}"
                echo
            } >> docker-compose.proxy.yaml

            print_info "A docker-compose.proxy.yaml was added."
        fi

        if [[ ! -f "$ENV_FILE" ]]; then
            {
                echo "# docker-compose configuration"
                echo "CON_PREFIX=${DOMAIN_PREFIX}"
                echo "PHP_IMAGE=php:fpm"
                echo "WEB_IMAGE=nginx/nginx:latest"
                echo "NETWORK=proxy-network"
                echo
            } >> .env

            print_info "A .env was added."
        fi

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

elif [[ "do" == "$ENVIRONMENT" ]]; then
    # stop, then remove all containers
    if [[ "finish" == "$ACTION" ]]; then
        REMOVABLE_CONTAINERS=$(docker ps -aq)
        if [[ ! -z "$REMOVABLE_CONTAINERS" ]]; then
            docker stop $REMOVABLE_CONTAINERS
            docker rm -f $REMOVABLE_CONTAINERS
        else
            print_info "No containers to stop."
        fi

        if [[ -f "$TEMP_HOSTS_PATH" ]]; then
            rm "$TEMP_HOSTS_PATH"
        fi

    # remove all stopped containers
    elif [[ "remove" == "$ACTION" ]]; then
        EXITED_CONTAINERS=$(docker ps -aq -f status="exited")
        if [[ ! -z "$EXITED_CONTAINERS" ]]; then
            docker rm -f $EXITED_CONTAINERS
        else
            print_info "No containers to remove."
        fi

    # remove all images that are no more in use
    elif [[ "cleanup" == "$ACTION" ]]; then
        CLEANABLE_CONTAINERS=$(docker images | grep "<none>" | awk "{print \$3}")
        if [[ ! -z "$CLEANABLE_CONTAINERS" ]]; then
            docker rmi -f "$CLEANABLE_CONTAINERS"
        else
            print_info "No unfinished build layers to remove."
        fi

    # test, if a container is running
    elif [[ "watch-running" == "$ACTION" || "watchrunning" == "$ACTION" || "watch" == "$ACTION" ]]; then
        CONTAINER="${PARAMETERS[0]}"

        if [[ -z "$CONTAINER" ]]; then
            print_error "To test a container, please provide its name!" 1
            exit 1
        fi

        STATE=`docker ps -a --format "table {{.Status}}\t{{.Names}}" | grep "$CONTAINER"`

        if [[ $STATE == *"Up "* ]]; then
            echo "TRUE"
        else
            echo "FALSE"
        fi

    # print the current state of Docker into a file
    elif [[ "status" == "$ACTION" ]]; then
        # let's see, if a file name was given
        REAL_STATUS_FILE="$STATUS_FILE_NAME"

        if [[ 0 != "${#PARAMETERS[@]}" ]]; then
            REAL_STATUS_FILE="${PARAMETERS[0]}"
        fi

        # create the full path and ask for confirmation
        STATUS_PATH="$CURRENT_DIR/$REAL_STATUS_FILE"
        read -r -p "A file $REAL_STATUS_FILE will be created (or override existing). Continue? [Y/n]" input

        case $input in
            [yY][eE][sS]|[yY])
                # remove the existing file
                if [[ -f "$STATUS_PATH" ]]; then
                    rm -f "$STATUS_PATH"
                fi

                # print out status info into a static file
                echo "### Currently running containers" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                docker ps -a --format "table {{.Image}}\t{{.Status}}\t{{.Ports}}\t{{.Names}}" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                echo "### Currently existing images" >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                docker images >> "$STATUS_PATH"
                echo "" >> "$STATUS_PATH"
                ;;
            *)
                print_error "Canceled..." 1
                ;;
        esac

    # use prompts to generate certificates for browser usage
    # see https://gist.github.com/fntlnz/cf14feb5a46b2eda428e000157447309
    # see https://two-oes.medium.com/working-with-openssl-and-dns-alternative-names-367f06a23841
    # see https://www.openssl.org/docs/manmaster/man5/x509v3_config.html
    # to test a .crt file, try: openssl x509 -in certs/docker.test.crt -text -noout
    elif [[ "init-certs" == "$ACTION" || "initcerts" == "$ACTION" ]]; then
        command -v openssl > /dev/null 2>&1 || {
            print_error "Openssl seems not to be installed on this machine. But it is necessary to generate keys..." 1
            exit 1
        }

        # create the certs path, if not done, yet
        if [[ ! -d "$CERTS_PATH" ]]; then
            mkdir -p "$CERTS_PATH"
        fi

        # some security info
        print_info "Attention: This is the key used to sign the certificate requests. Anyone holding this can sign certificates on your behalf. So keep it safe!"

        # ask the user for some details on the certificate
        RSA_KEY_LENGTH=`match_answer_or_default "Define a key size [4096]: " 4096`
        RSA_VALID_DAYS=`match_answer_or_default "How long shall this certificate be valid (in days) [3650]: " 3650`
        RSA_COUNTRY_NAME=`match_answer_or_default "Country Name (2 letter code) [PS]: " "PS"`
        RSA_STATE_NAME=`match_answer_or_default "State or Province Name (full name) [Proxy Environment]: " "Proxy Environment"`
        RSA_LOCALITY_NAME=`match_answer_or_default "Locality Name (some city) [Proxy]: " "Proxy"`
        RSA_ORG_NAME=`match_answer_or_default "Organization Name (some company) [Docker Proxy Stack]: " "Docker Proxy Stack"`
        RSA_ORGUNIT_NAME=`match_answer_or_default "Organizational Unit Name (a section) [Docker Proxy Stack]: " "Docker Proxy Stack"`
        RSA_EMAIL=`match_answer_or_default "E-Mail Address []: " ""`

        # create complex variables
        DOMAIN_ALT_NAMES="DNS:docker.test,DNS:*.docker.test,DNS:localhost,DNS:127.0.0.1,DNS:0:0:0:0:0:0:0:1"
        CERT_SUBJECT="/C=$RSA_COUNTRY_NAME/ST=$RSA_STATE_NAME/L=$RSA_LOCALITY_NAME/O=$RSA_ORG_NAME/OU=$RSA_ORGUNIT_NAME/emailAddress=$RSA_EMAIL/CN=docker.test"

        # create a root key and rootCA for docker.test
        openssl genrsa -out "$CERTS_PATH/rootCA.key" $RSA_KEY_LENGTH
        openssl req -x509 -new -nodes -sha256 \
            -key "$CERTS_PATH/rootCA.key" \
            -subj "$CERT_SUBJECT" \
            -days $RSA_VALID_DAYS \
            -out "$CERTS_PATH/rootCA.crt"

        # create a certificate for docker.test
        openssl genrsa -out "$CERTS_PATH/docker.test.key" $RSA_KEY_LENGTH
        openssl req -new -sha256 \
            -key "$CERTS_PATH/docker.test.key" \
            -subj "$CERT_SUBJECT" \
            -reqexts SAN \
            -config <(cat /etc/ssl/openssl.cnf <(printf "\n[SAN]\nsubjectAltName=$DOMAIN_ALT_NAMES")) \
            -out "$CERTS_PATH/docker.test.csr"

        # last step: sign the domain certificate with the rootCA
        openssl x509 -req -sha256 -CAcreateserial \
            -in "$CERTS_PATH/docker.test.csr" \
            -CA "$CERTS_PATH/rootCA.crt" \
            -CAkey "$CERTS_PATH/rootCA.key" \
            -out "$CERTS_PATH/docker.test.crt" \
            -days $RSA_VALID_DAYS \
            -extfile <(printf "subjectAltName=$DOMAIN_ALT_NAMES")

        print_info "Done creating rootCA and certificates in $CERTS_PATH."
        print_info "Now register the rootCA.crt in your browser." 1

    # shortcut to list all docker containers
    elif [[ "self-update" == "$ACTION" || "selfupdate" == "$ACTION" ]]; then
        # get_latest_git_tag will cd us into the $BASE_DIR directory
        LATEST_TAG=`get_latest_git_tag`
        git checkout --quiet $LATEST_TAG
        print_info "Updated the Docker Proxy Stack. Checked out version $LATEST_TAG." 1

    # shortcut to list all docker containers
    elif [[ "ps" == "$ACTION" ]]; then
        docker ps -a --format "table {{.Image}}\t{{.Status}}\t{{.Ports}}\t{{.Names}}"

    else
        print_error "Unknown option '$ACTION'..." 1
        exit 1
    fi

else
    print_error "There is no environment named '$ENVIRONMENT'..." 1
    exit 1
fi

exit 0
